
# Generated by CodiumAI
from django.urls import reverse
from multitenancy.billing import gateways
from django.test import RequestFactory, TestCase, Client

from http.client import GATEWAY_TIMEOUT

from multitenancy.billing.serializers import PaymentSerializer

from multitenancy.billing.serializers import PaymentGatewaySerializer
from multitenancy.billing.views import CreditViewSet, PaymentViewSet, RefundViewSet

from multitenancy.subscriptions.tests.test_serializers import SubscriptionSerializerTestCase

from multitenancy.subscriptions.views import SubscriptionsViewSet

from multitenancy.subscriptions.views import SubscriptionsListView

from multitenancy.subscriptions.serializers import SubscriptionSerializer

from multitenancy.subscriptions.models import SubscriptionQueryset
from multitenancy.billing.views import InvoiceViewSet

from multitenancy.subscriptions.apps import SubscriptionsConfig

from multitenancy.subscriptions.models import Subscription
from multitenancy import subscriptions
from datetime import date
from datetime import timedelta

from multitenancy.billing.models import Payment

from psycopg2 import DatabaseError

from helpdesk.views.staff import get_template_staff_and_template_cc

from multitenancy.billing.views import PaymentView

from multitenancy.billing.models import PaymentGateWay

from multitenancy.billing.views import PaymentGatewaysView

from unittest.mock import MagicMock

from multitenancy.billing.models import Refund

from multitenancy.billing.views import RefundsListView

import datetime

from unittest.mock import Mock

from multitenancy.apps.models import Tenant
from multitenancy.billing.models import Credit


from django.test import RequestFactory
from multitenancy.billing.views import CreditsListView

from django.http import HttpResponse
from multitenancy.billing.models import Invoice

from multitenancy.billing.forms import InvoiceForm

from multitenancy.billing.views import InvoiceListView

from django.http import HttpResponseForbidden
from django.contrib.auth.models import AnonymousUser

from requests import Request
from requests import patch

from django.http import HttpRequest
from django.http import HttpResponseForbidden
from django.core.exceptions import PermissionDenied
from multitenancy.billing.views import BillingIndexView
from django.contrib.auth.models import Permission
from django.conf import settings

User = settings.AUTH_USER_MODEL


import unittest

# class TestBillingIndexView(unittest.TestCase):

#     def setUp(self):
#             self.factory = RequestFactory()
#             self.client = Client()
        

#     # Test that the BillingIndexView is accessible for an authenticated user with type 'Admin'
#     def test_authenticated_admin(self):
#         # Create a user with type 'Admin'
#         user = User.objects.create_user(username='admin', email="admin3234@gmail.com", password='password', type='Admin')
    
#         # Log in the user
#         self.client.login(username='admin', password='password')
    
#         # Make a GET request to the BillingIndexView
        
#         response = self.client.get('/admin/billing/')
    
#         # Assert that the response status code is 200 (OK)
#         self.assertEqual(response.status_code, 200)
    
#         # Assert that the correct template is used
#         self.assertTemplateUsed(response, 'multitenancy/billing/billing.html')


#     # Test that the billing template is rendered successfully
#     def test_render_billing_template(self):
#         view = BillingIndexView()
#         response = view.get(self)
#         self.assertEqual(response.status_code, 200)
#         self.assertTemplateUsed(response, 'multitenancy/billing/billing.html')


#     # Test that the handle_no_permission method is called when the user is not authenticated
#     def test_user_not_authenticated(self):
#         view = BillingIndexView()
#         request = HttpRequest()
#         request.user = AnonymousUser()
#         response = view.dispatch(request)
#         self.assertEqual(response.status_code, 403)


#     # Test that the handle_no_permission method is called when the user is authenticated but has a type other than 'Admin'
#     def test_authenticated_user_with_non_admin_type(self):
#         # Create a user with authenticated status and type other than 'Admin'
#         user = User(is_authenticated=True, type='User')
    
#         # Create a request object with the user
#         request = Request(user=user)
    
#         # Create an instance of BillingIndexView
#         view = BillingIndexView(request=request)
    
#         # Mock the handle_no_permission method
#         with patch.object(view, 'handle_no_permission') as mock_handle_no_permission:
#             # Call the dispatch method
#             view.dispatch(request)
        
#             # Assert that the handle_no_permission method was called
#             mock_handle_no_permission.assert_called_once()


#     # Test that when a user is authenticated but has no permission to access the view, the handle_no_permission method is called and returns a HttpResponseForbidden object.
#     def test_no_permission(self):
#         # Create a mock request object
#         request = HttpRequest()
#         request.user = User.objects.create_user(username='testuser', password='testpassword', type='User')

#         # Create an instance of BillingIndexView
#         view = BillingIndexView()

#         # Call the test_func method to check if the user has permission
#         has_permission = view.test_func(request)

#         # Assert that the user does not have permission
#         self.assertFalse(has_permission)

#         # Call the handle_no_permission method
#         response = view.handle_no_permission()

#         # Assert that the response is a HttpResponseForbidden object
#         self.assertIsInstance(response, HttpResponseForbidden)


#     # Test that the context dictionary in BillingIndexView contains the user object
#     def test_context_contains_user_object(self):
#         view = BillingIndexView()
#         request = HttpRequest()
#         request.user = User.objects.create(username='admin', type='Admin')
#         view.request = request
#         context = view.get_context_data()
#         self.assertEqual(context['user'], request.user)


#     # Test that the redirect field name is set to 'next'
#     def test_redirect_field_name(self):
#         view = BillingIndexView()
#         self.assertEqual(view.redirect_field_name, 'next')


#     # Test that the handle_no_permission method of BillingIndexView returns an HttpResponseForbidden object
#     def test_handle_no_permission_returns_HttpResponseForbidden(self):
#         view = BillingIndexView()
#         response = view.handle_no_permission()
#         self.assertIsInstance(response, HttpResponseForbidden)


#     # Test that the template used for permission denied is 'permission_denied.html'
#     def test_permission_denied_template(self):
#         view = BillingIndexView()
#         response = view.handle_no_permission()
#         self.assertEqual(response.status_code, 403)
#         self.assertTemplateUsed(response, 'permission_denied.html')

class TestBillingIndexView(TestCase):
    def setUp(self):
        self.factory = RequestFactory()

    def test_authenticated_admin(self):
        admin = User.objects.create_user(username='admin', email="admin3234@gmail.com", password='password', type='Admin')
        admin.user_permissions.add(Permission.objects.get(codename='view_billingindexview'))
        self.client.login(username='admin', password='password')
        response = self.client.get(reverse('billing-index'))
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'multitenancy/billing/billing.html')

    def test_render_billing_template(self):
        request = self.factory.get('/billing/')
        view = BillingIndexView.as_view()
        response = view(request)
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'multitenancy/billing/billing.html')

    def test_user_not_authenticated(self):
        request = self.factory.get('/billing/')
        request.user = AnonymousUser()
        view = BillingIndexView.as_view()
        response = view(request)
        self.assertEqual(response.status_code, 403)

    def test_authenticated_user_with_non_admin_type(self):
        user = User(is_authenticated=True, type='User')
        request = self.factory.get('/billing/')
        request.user = user
        view = BillingIndexView.as_view()
        with patch.object(view, 'handle_no_permission') as mock_handle_no_permission:
            response = view(request)
            mock_handle_no_permission.assert_called_once_with()
            self.assertEqual(response.status_code, 403)

    def test_no_permission(self):
        user = User.objects.create_user(username='testuser', password='testpassword', type='User')
        request = self.factory.get('/billing/')
        request.user = user
        view = BillingIndexView.as_view()
        with self.assertRaises(PermissionDenied):
            view(request)

    def test_context_contains_user_object(self):
        admin = User.objects.create(username='admin', type='Admin')
        request = self.factory.get('/billing/')
        request.user = admin
        view = BillingIndexView.as_view()
        response = view(request)
        self.assertEqual(response.context_data['user'], admin)

    def test_redirect_field_name(self):
        view = BillingIndexView()
        self.assertEqual(view.redirect_field_name, 'next')

    def test_handle_no_permission_returns_HttpResponseForbidden(self):
        view = BillingIndexView()
        response = view.handle_no_permission()
        self.assertIsInstance(response, HttpResponseForbidden)

    def test_permission_denied_template(self):
        view = BillingIndexView()
        response = view.handle_no_permission()
        self.assertEqual(response.status_code, 403)
        self.assertTemplateUsed(response, 'permission_denied.html')



# class TestInvoiceListView(unittest.TestCase):
#     def setUp(self):
#             self.factory = RequestFactory()
#             self.client = Client()
#     # Test that the invoice_list.html template is rendered correctly
#     def test_render_invoice_list_template(self):
#         view = InvoiceListView()
#         request = HttpRequest()
#         response = view.get(request)
#         self.assertEqual(response.status_code, 200)
#         self.assertTemplateUsed(response, 'multitenancy/billing/invoice_list.html')


#     # Test that the InvoiceForm instance is included in the context of the InvoiceListView
#     def test_invoice_form_instance_in_context(self):
#         invoice_list_view = InvoiceListView()
#         context = invoice_list_view.get_context_data()
#         form = context['form']
#         self.assertIsInstance(form, InvoiceForm)


#     # Test that when there is no authenticated user, the InvoiceListView redirects to the login page.
#     def test_no_authenticated_user_redirects_to_login_page(self):
#         # Create a request object without an authenticated user
#         request = HttpRequest()
    
#         # Create an instance of InvoiceListView
#         view = InvoiceListView()
    
#         # Set the request object as the request attribute of the view
#         view.request = request
    
#         # Call the dispatch method of the view
#         response = view.dispatch(request)
    
#         # Assert that the response is a redirect to the login page
#         self.assertEqual(response.status_code, 302)
#         self.assertEqual(response.url, '/login/')


#     # Test that when an authenticated user is not an admin, the view returns a 403 Forbidden response.
#     def test_unauthenticated_user_not_admin(self):
#         # Create a user that is authenticated but not an admin
#         user = User.objects.create_user(username='testuser', password='testpassword')
#         self.client.force_login(user)
    
#         # Make a GET request to the view
#         response = self.client.get('/admin/invoices/')
    
#         # Assert that the response status code is 403 Forbidden
#         self.assertEqual(response.status_code, 403)


#     # Test that a form POST with valid data creates a new Invoice instance and redirects to the invoice detail page
#     def test_form_post_with_valid_data(self):
#         # Create a mock request object
#         request = HttpRequest()
#         request.method = 'POST'
#         request.user = User.objects.create(type='Admin')
#         request.POST = {
#             'subscription': 'Test Subscription',
#             'due_date': '2022-01-01',
#             'invoice_number': '12345',
#             'amount': 100.00,
#             'credit_used': 50.00,
#             'payment_method': 'Credit Card',
#             'status': 'Paid',
#             'notes': 'Test notes'
#         }
    
#         # Create a mock response object
#         response = HttpResponse()
    
#         # Create an instance of InvoiceListView
#         view = InvoiceListView()
#         view.request = request
#         view.response = response
    
#         # Call the get_context_data method
#         context = view.get_context_data()
    
#         # Assert that the form is in the context
#         self.assertIn('form', context)
    
#         # Get the form from the context
#         form = context['form']
    
#         # Assert that the form is an instance of InvoiceForm
#         self.assertIsInstance(form, InvoiceForm)
    
#         # Call the form's save method
#         invoice = form.save()
    
#         # Assert that a new Invoice instance was created
#         self.assertIsInstance(invoice, Invoice)
    
#         # Assert that the invoice detail page was redirected to
#         self.assertEqual(response.status_code, 302)
#         self.assertEqual(response.url, '/invoice/detail/{}'.format(invoice.id))


#     # Test that when a form is submitted with invalid data, the invoice_list.html template is re-rendered with errors
#     def test_form_post_with_invalid_data(self):
#         # Create a mock request object
#         request = HttpRequest()
#         request.method = 'POST'
#         request.user = User.objects.create(username='admin', type='Admin')
    
#         # Create a mock form with invalid data
#         form_data = {
#             'subscription': '123',
#             'due_date': '2022-01-01',
#             'invoice_number': '',
#             'amount': '100',
#             'credit_used': '50',
#             'payment_method': '',
#             'status': '',
#             'notes': '',
#         }
#         form = InvoiceForm(data=form_data)
    
#         # Create a mock view object
#         view = InvoiceListView()
#         view.request = request
    
#         # Set the form in the context data
#         context = view.get_context_data()
#         context['form'] = form
    
#         # Call the handle_no_permission method
#         response = view.handle_no_permission()
    
#         # Assert that the response is an instance of HttpResponseForbidden
#         self.assertIsInstance(response, HttpResponseForbidden)
    
#         # Assert that the response content contains the expected error messages
#         self.assertIn('This field is required.', response.content.decode())
#         self.assertIn('This field is required.', response.content.decode())


#     # Test that the InvoiceListView filters invoices by subscription and renders the invoice_list.html template when receiving a GET request with a search query parameter.
#     def test_get_request_with_search_query_parameter(self):
#         # Create a mock request object with a search query parameter
#         request = self.client.get('/path/to/invoice/list/?search=subscription')

#         # Create a mock user object with type 'Admin'
#         user = User.objects.create_user(username='admin', password='password', type='Admin')

#         # Assign the mock user object to the request
#         request.user = user

#         # Create a mock response object
#         response = InvoiceListView.as_view()(request)

#         # Assert that the response status code is 200 (OK)
#         self.assertEqual(response.status_code, 200)

#         # Assert that the response template name is 'multitenancy/billing/invoice_list.html'
#         self.assertEqual(response.template_name, 'multitenancy/billing/invoice_list.html')

#         # Assert that the response context contains the InvoiceForm
#         self.assertIsInstance(response.context_data['form'], InvoiceForm)

#         # Assert that the invoices are filtered by subscription
#         invoices = response.context_data['invoices']
#         for invoice in invoices:
#             self.assertEqual(invoice.subscription, 'subscription')


#     # Test that the InvoiceListView class properly paginates invoices and renders the invoice_list.html template when a GET request with a page query parameter is made.
#     def test_get_request_with_page_query_parameter(self):
#         # Create a mock request object with a GET parameter for the page
#         request = self.client.get('/invoices/?page=2')
    
#         # Create an instance of the InvoiceListView class
#         view = InvoiceListView()
    
#         # Set the request attribute of the view to the mock request object
#         view.request = request
    
#         # Call the get_context_data method of the view
#         context = view.get_context_data()
    
#         # Assert that the context contains the expected form
#         self.assertIsInstance(context['form'], InvoiceForm)
    
#         # Assert that the template name is correct
#         self.assertEqual(view.template_name, "multitenancy/billing/invoice_list.html")

class TestInvoiceListView(TestCase):
    def setUp(self):
        self.factory = RequestFactory()

    def test_render_invoice_list_template(self):
        request = HttpRequest()
        view = InvoiceListView()
        response = view.get(request)
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'multitenancy/billing/invoice_list.html')

    def test_invoice_form_instance_in_context(self):
        request = HttpRequest()
        invoice_list_view = InvoiceListView()
        invoice_list_view.request = request
        context = invoice_list_view.get_context_data()
        form = context['form']
        self.assertIsInstance(form, InvoiceForm)

    def test_no_authenticated_user_redirects_to_login_page(self):
        request = HttpRequest()
        view = InvoiceListView()
        view.request = request
        response = view.dispatch(request)
        self.assertEqual(response.status_code, 302)
        self.assertEqual(response.url, '/login/')

    def test_unauthenticated_user_not_admin(self):
        user = User.objects.create_user(username='testuser', password='testpassword', email='admin@iisk.com')
        request = HttpRequest()
        request.user = user
        self.client.force_login(user)
        response = self.client.get('/admin/invoices/')
        self.assertEqual(response.status_code, 403)

    def test_form_post_with_valid_data(self):
        request = HttpRequest()
        request.method = 'POST'
        user = User.objects.create(username='admin', type='Admin', email='admin8377@email.com')
        request.user = user
        request.POST = {
            'subscription': 'Test Subscription',
            'due_date': '2022-01-01',
            'invoice_number': '12345',
            'amount': 100.00,
            'credit_used': 50.00,
            'payment_method': 'Credit Card',
            'status': 'Paid',
            'notes': 'Test notes'
        }
        response = HttpResponse()
        view = InvoiceListView()
        view.request = request
        view.response = response
        context = view.get_context_data()
        self.assertIn('form', context)
        form = context['form']
        self.assertIsInstance(form, InvoiceForm)
        invoice = form.save()
        self.assertIsInstance(invoice, Invoice)
        self.assertEqual(response.status_code, 302)
        self.assertEqual(response.url, '/invoice/detail/{}'.format(invoice.id))

    def test_form_post_with_invalid_data(self):
        request = HttpRequest()
        request.method = 'POST'
        user = User.objects.create(username='admin', type='Admin', email='admin00909@gmail.com')
        request.user = user
        form_data = {
            'subscription': '123',
            'due_date': '2022-01-01',
            'invoice_number': '',
            'amount': '100',
            'credit_used': '50',
            'payment_method': '',
            'status': '',
            'notes': '',
        }
        form = InvoiceForm(data=form_data)
        view = InvoiceListView()
        view.request = request
        context = view.get_context_data()
        context['form'] = form
        response = view.handle_no_permission()
        self.assertIsInstance(response, HttpResponseForbidden)
        self.assertIn('This field is required.', response.content.decode())

    def test_get_request_with_search_query_parameter(self):
        request = self.factory.get('/path/to/invoice/list/?search=subscription')
        user = User.objects.create_user(username='admin', password='password', type='Admin', email='admin39749@email.com')
        request.user = user
        response = InvoiceListView.as_view()(request)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.template_name, 'multitenancy/billing/invoice_list.html')
        self.assertIsInstance(response.context_data['form'], InvoiceForm)
        invoices = response.context_data['invoices']
        for invoice in invoices:
            self.assertEqual(invoice.subscription, 'subscription')

    def test_get_request_with_page_query_parameter(self):
        request = self.factory.get('/invoices/?page=2')
        view = InvoiceListView()
        view.request = request
        context = view.get_context_data()
        self.assertIsInstance(context['form'], InvoiceForm)
        self.assertEqual(view.template_name, "multitenancy/billing/invoice_list.html")



class TestCreditsListView(unittest.TestCase):
    def setUp(self):
            self.factory = RequestFactory()
            self.client = Client()
    # Test that the CreditsListView is accessible to authenticated Admin users
    def test_credits_list_view_accessible_to_admin_users(self):
        # Create a mock request object with an authenticated Admin user
        request = RequestFactory().get('/')
        request.user = User.objects.create_user(username='admin', password='admin123', type='Admin', email='admin299@email.com')
    
        # Create an instance of the CreditsListView
        view = CreditsListView()
        view.request = request
    
        # Call the test_func method to check if the user has permission
        has_permission = view.test_func()
    
        # Assert that the user has permission
        self.assertTrue(has_permission)


    # Test that the CreditsListView displays a list of credits for the current tenant
    def test_display_credits_list(self):
        # Create a mock user
        user = User.objects.create(username='admin', type='Admin')
        self.client.force_login(user)
    
        # Create a mock tenant
        tenant = Tenant.objects.create(name='Test Tenant')
    
        # Create some mock credits for the tenant
        Credit.objects.create(tenant=tenant, amount=100)
        Credit.objects.create(tenant=tenant, amount=200)
    
        # Make a GET request to the CreditsListView
        response = self.client.get(reverse('credits_list'))
    
        # Check that the response status code is 200
        self.assertEqual(response.status_code, 200)
    
        # Check that the rendered template is correct
        self.assertTemplateUsed(response, 'multitenancy/billing/credits_list.html')
    
        # Check that the credits are displayed in the response context
        credits = response.context['credits']
        self.assertEqual(len(credits), 2)
        self.assertEqual(credits[0].amount, 100)
        self.assertEqual(credits[1].amount, 200)


    # Test that the CreditsListView displays the remaining credits for the current tenant
    def test_display_remaining_credits(self):
        # Create a mock user with type 'Admin'
        user = User(type='Admin')
        # Create a mock request with the mock user
        request = HttpRequest()
        request.user = user
    
        # Create an instance of CreditsListView
        view = CreditsListView()
        view.request = request
    
        # Call the get method of the view
        response = view.get(request)
    
        # Assert that the response contains the remaining credits for the current tenant
        self.assertContains(response, "Remaining credits: X")


    # Test that the CreditsListView redirects unauthenticated users to the login page
    def test_redirect_unauthenticated_users_to_login_page(self):
        # Create a request object with an unauthenticated user
        request = HttpRequest()
        request.user = AnonymousUser()

        # Create an instance of the CreditsListView class
        view = CreditsListView()

        # Call the dispatch method of the view with the request object
        response = view.dispatch(request)

        # Assert that the response is a redirect to the login page
        self.assertEqual(response.status_code, 302)
        self.assertEqual(response.url, '/login/')


    # Test that CreditsListView redirects non-Admin users to a permission denied page
    def test_redirect_non_admin_users(self):
        # Create a non-Admin user
        user = User.objects.create_user(username='testuser', password='testpassword', type='User', email='admin898776@email.com')
    
        # Create a request object with the non-Admin user
        request = HttpRequest()
        request.user = user
    
        # Create an instance of CreditsListView
        view = CreditsListView()
        view.request = request
    
        # Call the dispatch method of CreditsListView
        response = view.dispatch(request)
    
        # Check that the response status code is 403 (Forbidden)
        self.assertEqual(response.status_code, 403)


    # Test that the CreditsListView displays a message when there are no credits available
    def test_display_message_no_credits(self):
        # Create a mock request object
        request = HttpRequest()
        request.user = User(type='Admin')
    
        # Create an instance of CreditsListView
        view = CreditsListView()
        view.request = request
    
        # Call the get method of the view
        response = view.get(request)
    
        # Assert that the response contains the expected message
        self.assertContains(response, "No credits available")


    # Test that the credits in the credits list can be sorted by date or amount
    def test_sort_credits(self):
        # Create test data
        credits = [
            {'date': '2021-01-01', 'amount': 100},
            {'date': '2021-02-01', 'amount': 200},
            {'date': '2021-03-01', 'amount': 150},
        ]
    
        # Set up the view
        view = CreditsListView()
        view.request = Mock()
        view.request.user = Mock()
        view.request.user.is_authenticated = True
        view.request.user.type = 'Admin'
    
        # Set up the request
        request = HttpRequest()
        request.GET = {'sort_by': 'date'}
    
        # Set up the template
        template = Mock()
        template.render = Mock(return_value='rendered template')
    
        # Set up the response
        response = view.get(request)
        response.render = Mock(return_value='rendered response')
    
        # Assert that the template was rendered with the correct context
        template.render.assert_called_once_with({'user': view.request.user, 'credits': credits}, request=request)
    
        # Assert that the response was rendered with the correct content
        response.render.assert_called_once_with()
    
        # Assert that the response content is the rendered template
        self.assertEqual(response.content, 'rendered template')


    # Test that the CreditsListView class allows filtering of credits by date range
    def test_filter_credits_by_date_range(self):
        # Create a mock request object
        request = HttpRequest()
        request.user = User(type='Admin')
    
        # Create a mock response object
        response = HttpResponse()
    
        # Create an instance of the CreditsListView class
        view = CreditsListView()
        view.request = request
        view.response = response
    
        # Set the date range filter parameters
        start_date = datetime.date(2021, 1, 1)
        end_date = datetime.date(2021, 12, 31)
    
        # Call the filter_credits_by_date_range method
        filtered_credits = view.filter_credits_by_date_range(start_date, end_date)
    
        # Assert that the filtered_credits is not empty
        self.assertNotEqual(len(filtered_credits), 0)


    # Test that CreditsListView displays a message if the date range filter returns no results
    def test_display_message_if_no_results(self):
        # Create a mock request object
        request = HttpRequest()
        request.user = User(type='Admin')
    
        # Create a mock response object
        response = self.client.get('/credits/', {'start_date': '2022-01-01', 'end_date': '2022-01-31'})
    
        # Assert that the response contains the expected message
        self.assertContains(response, "No results found for the selected date range")


    # Test that a message is displayed when the user tries to access credits for a different tenant
    def test_display_message_for_different_tenant(self):
        # Create a user with type 'Admin'
        admin_user = User.objects.create_user(username='admin', password='admin123', type='Admin', email='admin20090@email.com')
    
        # Create a tenant
        tenant = Tenant.objects.create(name='Tenant1')
    
        # Create a user with type 'User' and assign it to the tenant
        user = User.objects.create_user(username='user', password='user123', type='User', tenant=tenant, email='admin40f@email.com')
    
        # Log in as the admin user
        self.client.login(username='admin', password='admin123')
    
        # Access the credits list view for the user's tenant
        response = self.client.get('/credits/')
    
        # Check that the response contains the expected message
        self.assertContains(response, "You do not have permission to access this page.")
    
        # Log out
        self.client.logout()



class TestRefundsListView(unittest.TestCase):
    def setUp(self):
            self.factory = RequestFactory()
            self.client = Client()
    # Test that the refunds_list.html template is rendered when the user is authenticated and has 'Admin' type
    def test_render_refunds_list(self):
        # Create a user with 'Admin' type
        user = User.objects.create_user(username='admin', password='password')
        user.type = 'Admin'
        user.save()
    
        # Authenticate the user
        self.client.force_login(user)
    
        # Make a GET request to the refunds list view
        response = self.client.get('/admin/refunds/')
    
        # Check that the response status code is 200 (OK)
        self.assertEqual(response.status_code, 200)
    
        # Check that the refunds_list.html template is used
        self.assertTemplateUsed(response, 'multitenancy/billing/refunds_list.html')


    # Test that the refunds_list.html template is rendered with refunds data when the user is authenticated and has the 'Admin' type
    def test_render_refunds_list_authenticated_admin(self):
        # Create a user with 'Admin' type
        user = User.objects.create_user(username='admin', password='admin123', type='Admin')
    
        # Authenticate the user
        self.client.force_login(user)
    
        # Make a GET request to the refunds list view
        response = self.client.get('/admin/refunds/')
    
        # Check that the response status code is 200 (OK)
        self.assertEqual(response.status_code, 200)
    
        # Check that the refunds_list.html template is used
        self.assertTemplateUsed(response, 'multitenancy/billing/refunds_list.html')
    
        # Check that the refunds data is passed to the template context
        self.assertIn('refunds', response.context)


    # Test that the permission denied page is rendered when the user is not authenticated
    def test_permission_denied_page_rendered(self):
        # Create a request object with an unauthenticated user
        request = HttpRequest()
        request.user = AnonymousUser()

        # Create an instance of RefundsListView
        refunds_list_view = RefundsListView()

        # Call the handle_no_permission method
        response = refunds_list_view.handle_no_permission(request)

        # Assert that the response status code is 403 (Forbidden)
        self.assertEqual(response.status_code, 403)

        # Assert that the response content contains the expected message
        self.assertIn("Permission Denied", response.content.decode())


    # Test that the permission denied page is rendered when the user is authenticated but does not have 'Admin' type
    def test_permission_denied_page_rendered(self):
        # Create a user with authenticated status but not 'Admin' type
        user = User.objects.create_user(username='testuser', password='testpassword')
        user.type = 'User'
        user.save()
    
        # Create a request with the created user
        request = HttpRequest()
        request.user = user
    
        # Create an instance of RefundsListView
        refunds_list_view = RefundsListView()
        refunds_list_view.request = request
    
        # Call the handle_no_permission method
        response = refunds_list_view.handle_no_permission()
    
        # Check that the response status code is 403 (Forbidden)
        self.assertEqual(response.status_code, 403)
    
        # Check that the response content contains the permission denied message
        self.assertIn('Permission Denied', response.content.decode())


    # Test that the pagination works correctly for a large number of refunds
    def test_pagination_for_large_number_of_refunds(self):
        # Create a large number of refunds
        refunds = []
        for i in range(100):
            refund = Refund.objects.create(amount=i)
            refunds.append(refund)
    
        # Set up the request and view
        request = RequestFactory().get('/refunds/')
        view = RefundsListView.as_view()
    
        # Set up the pagination
        view.paginate_by = 10
        view.kwargs = {}
    
        # Get the response
        response = view(request)
    
        # Check that the response contains the correct number of refunds
        self.assertEqual(len(response.context_data['object_list']), 10)
    
        # Check that the pagination links are correct
        self.assertEqual(response.context_data['paginator'].num_pages, 10)
        self.assertEqual(response.context_data['paginator'].page_range, range(1, 11))


    # Test that the refunds in the RefundsListView are sorted correctly by date or amount
    def test_sort_refunds(self):
        # Create some refund objects with different dates and amounts
        refund1 = Refund(date=datetime.date(2021, 1, 1), amount=100)
        refund2 = Refund(date=datetime.date(2021, 2, 1), amount=200)
        refund3 = Refund(date=datetime.date(2021, 3, 1), amount=150)
    
        # Add the refunds to the view's context
        self.view = RefundsListView()
        self.view.get_context_data = MagicMock(return_value={'refunds': [refund1, refund2, refund3]})
    
        # Test sorting by date
        self.view.request.GET = {'sort': 'date'}
        response = self.view.get(self.view.request)
        sorted_refunds = response.context_data['refunds']
        self.assertEqual(sorted_refunds, [refund1, refund2, refund3])
    
        # Test sorting by amount
        self.view.request.GET = {'sort': 'amount'}
        response = self.view.get(self.view.request)
        sorted_refunds = response.context_data['refunds']
        self.assertEqual(sorted_refunds, [refund2, refund3, refund1])


    # Test that the search function in RefundsListView works correctly and returns the expected results
    def test_search_function(self):
        # Create a mock request object
        request = HttpRequest()
        request.user = User(type='Admin')
    
        # Create an instance of RefundsListView
        refunds_list_view = RefundsListView()
        refunds_list_view.request = request
    
        # Call the search function
        results = refunds_list_view.search()
    
        # Assert that the results are as expected
        self.assertEqual(results, expected_results)


    # Test that clicking on a refund redirects to the correct refund detail page
    def test_redirect_to_refund_detail(self):
        # Create a mock refund object
        refund = Refund.objects.create(amount=100, user=self.request.user)
    
        # Simulate clicking on the refund
        response = self.client.get(reverse('refund_detail', args=[refund.id]))
    
        # Assert that the response status code is 302 (redirect)
        self.assertEqual(response.status_code, 302)
    
        # Assert that the response redirects to the correct refund detail page
        self.assertEqual(response.url, reverse('refund_detail', args=[refund.id]))


    # Test that clicking on a refund's associated customer redirects to the correct customer detail page
    def test_customer_redirect(self):
        # Create a refund object
        refund = Refund.objects.create(customer_id=1)
    
        # Create a request object with the refund's associated customer ID
        request = RequestFactory().get('/customer/1/')
    
        # Create a user object with type 'Admin'
        user = User.objects.create(type='Admin')
    
        # Set the user object as the request's user
        request.user = user
    
        # Create an instance of RefundsListView
        view = RefundsListView()
    
        # Set the request object as the view's request
        view.request = request
    
        # Call the view's dispatch method
        response = view.dispatch(request)
    
        # Assert that the response status code is 302 (redirect)
        self.assertEqual(response.status_code, 302)
    
        # Assert that the response redirects to the correct customer detail page
        self.assertEqual(response.url, '/customer/1/')



class TestPaymentGatewaysView(unittest.TestCase):
    def setUp(self):
            self.factory = RequestFactory()
            self.client = Client()
    # Test that the payment gateways list template is rendered successfully when the user is authenticated and is an admin.
    def test_payment_gateways_list_template_rendered_successfully(self):
        # Create a mock user
        user = User.objects.create(username='admin', type='Admin')
        # Authenticate the user
        self.client.force_login(user)
    
        # Make a GET request to the PaymentGatewaysView
        response = self.client.get('/payment_gateways/')
    
        # Check that the response status code is 200 (OK)
        self.assertEqual(response.status_code, 200)
    
        # Check that the correct template is used
        self.assertTemplateUsed(response, 'multitenancy/billing/payment_gateways_list.html')


    # Test that when the user is not authenticated, they are redirected to the login page.
    def test_redirect_to_login(self):
        response = self.client.get('/payment_gateways/')
        self.assertEqual(response.status_code, 302)
        self.assertEqual(response.url, '/login/')


    # Test that a user who is authenticated but not an admin is shown a permission denied page.
    def test_permission_denied_page(self):
        # Create a user who is authenticated but not an admin
        user = User.objects.create_user(username='testuser', password='testpassword')
        user.is_authenticated = True
        user.type = 'User'
    
        # Create a request object with the user
        request = HttpRequest()
        request.user = user
    
        # Create an instance of PaymentGatewaysView
        view = PaymentGatewaysView()
        view.request = request
    
        # Call the handle_no_permission method
        response = view.handle_no_permission()
    
        # Check that the response is an HttpResponseForbidden
        self.assertIsInstance(response, HttpResponseForbidden)
    
        # Check that the response contains the permission denied message
        self.assertContains(response, 'Permission Denied')


    # Test that the payment gateways list is empty and the template is rendered successfully
    def test_empty_payment_gateways_list(self):
        # Create a mock request object
        request = HttpRequest()
        request.user = User.objects.create_user(username='admin', password='admin123', type='Admin')

        # Create an instance of PaymentGatewaysView
        view = PaymentGatewaysView.as_view()

        # Get the response from the view
        response = view(request)

        # Assert that the response status code is 200 (OK)
        self.assertEqual(response.status_code, 200)

        # Assert that the template used is "multitenancy/billing/payment_gateways_list.html"
        self.assertTemplateUsed(response, "multitenancy/billing/payment_gateways_list.html")


    # Test that the payment gateways list is not empty and the template is rendered successfully.
    def test_payment_gateways_list_not_empty(self):
        # Create a mock user with type 'Admin'
        user = User(type='Admin')
        # Create a mock request with the authenticated user
        request = RequestFactory().get('/')
        request.user = user
    
        # Create an instance of PaymentGatewaysView
        view = PaymentGatewaysView()
        view.request = request
    
        # Call the get method of PaymentGatewaysView
        response = view.get(request)
    
        # Assert that the payment gateways list is not empty
        self.assertNotEqual(response.context_data['payment_gateways'], [])
    
        # Assert that the template is rendered successfully
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'multitenancy/billing/payment_gateways_list.html')


    # Test that the payment gateways list is paginated and the correct page is displayed
    def test_payment_gateways_pagination(self):
        # Create a mock request object
        request = HttpRequest()
        request.user = User.objects.create_user(username='admin', password='admin123', type='Admin')

        # Create a mock response object
        response = self.client.get('/payment-gateways/')

        # Assert that the response status code is 200
        self.assertEqual(response.status_code, 200)

        # Assert that the correct template is used
        self.assertTemplateUsed(response, 'multitenancy/billing/payment_gateways_list.html')

        # Assert that the payment gateways are paginated
        self.assertContains(response, 'Page 1')
        self.assertNotContains(response, 'Page 2')


    # Test that the payment gateways list is sorted by name and is displayed in ascending order.
    def test_payment_gateways_list_sorted(self):
        # Create a list of payment gateways in unsorted order
        unsorted_gateways = [
            {'name': 'Gateway C'},
            {'name': 'Gateway A'},
            {'name': 'Gateway B'}
        ]
    
        # Create an instance of PaymentGatewaysView
        view = PaymentGatewaysView()
    
        # Set the payment gateways list in the view
        view.payment_gateways = unsorted_gateways
    
        # Call the get method to sort the payment gateways list
        view.get(self.request)
    
        # Check that the payment gateways list is sorted in ascending order by name
        sorted_gateways = [
            {'name': 'Gateway A'},
            {'name': 'Gateway B'},
            {'name': 'Gateway C'}
        ]
        self.assertEqual(view.payment_gateways, sorted_gateways)


    # Test that the payment gateways list is sorted by name and is displayed in descending order.
    def test_payment_gateways_list_sorted_descending(self):
        # Create dummy payment gateways
        gateway1 = PaymentGateWay(name="Gateway 1")
        gateway2 = PaymentGateWay(name="Gateway 2")
        gateway3 = PaymentGateWay(name="Gateway 3")
    
        # Save the payment gateways in reverse order
        gateway3.save()
        gateway2.save()
        gateway1.save()
    
        # Make a GET request to the view
        response = self.client.get(reverse('payment_gateways'))
    
        # Check that the response status code is 200
        self.assertEqual(response.status_code, 200)
    
        # Check that the payment gateways are sorted in descending order by name
        payment_gateways = response.context['payment_gateways']
        self.assertEqual(payment_gateways[0].name, "Gateway 3")
        self.assertEqual(payment_gateways[1].name, "Gateway 2")
        self.assertEqual(payment_gateways[2].name, "Gateway 1")



class TestPaymentView(unittest.TestCase):
    def setUp(self):
            self.factory = RequestFactory()
            self.client = Client()
    # Test that the payment template is rendered when the user is authenticated and is an admin
    def test_payment_template_rendered(self):
        # Create a mock user object with the required attributes
        class MockUser:
            is_authenticated = True
            type = 'Admin'
    
        # Create a mock request object with the mock user
        class MockRequest:
            user = MockUser()
    
        # Create an instance of PaymentView with the mock request
        view = PaymentView(request=MockRequest())
    
        # Use the assertTemplateUsed method to check if the payment template is rendered
        self.assertTemplateUsed(view, "multitenancy/billing/payments.html")


    # Test that the payment is successfully processed when the user is authenticated and is an admin
    def test_payment_successful(self):
        # Create a mock user with admin privileges
        user = User.objects.create(username='admin', type='Admin')
        user.set_password('password')
        user.save()
    
        # Log in the user
        self.client.login(username='admin', password='password')
    
        # Make a GET request to the PaymentView
        response = self.client.get('/payment/')
    
        # Assert that the response status code is 200 (successful)
        self.assertEqual(response.status_code, 200)
    
        # Assert that the correct template is used
        self.assertTemplateUsed(response, 'multitenancy/billing/payments.html')


    # Test that when the user is not authenticated, the PaymentView redirects to the login page
    def test_redirect_to_login(self):
        # Create a request object with an unauthenticated user
        request = HttpRequest()
        request.user = AnonymousUser()

        # Create an instance of PaymentView
        view = PaymentView()

        # Call the dispatch method of PaymentView with the request object
        response = view.dispatch(request)

        # Assert that the response is a redirect to the login page
        self.assertEqual(response.status_code, 302)
        self.assertEqual(response.url, '/login/')


    # Test that when a user is authenticated but not an admin, the PaymentView redirects to the permission denied page.
    def test_redirect_to_permission_denied(self):
        # Create a mock request object
        request = HttpRequest()
        request.user = Mock()
        request.user.is_authenticated = True
        request.user.type = 'User'

        # Create an instance of PaymentView
        view = PaymentView()

        # Call the dispatch method of PaymentView with the mock request object
        response = view.dispatch(request)

        # Assert that the response is an instance of HttpResponseForbidden
        self.assertIsInstance(response, HttpResponseForbidden)


    # Test that when the payment form is invalid, an error message is displayed
    def test_invalid_payment_form_error_message_displayed(self):
        # Create a mock request object
        request = HttpRequest()
        request.user = User.objects.create_user(username='admin', password='admin123', type='Admin')
    
        # Create a mock response object
        response = HttpResponse()
    
        # Create an instance of PaymentView
        payment_view = PaymentView()
        payment_view.request = request
        payment_view.response = response
    
        # Set the payment form to be invalid
        payment_view.payment_form.is_valid.return_value = False
    
        # Call the handle_no_permission method
        payment_view.handle_no_permission()
    
        # Assert that the error message is displayed in the response content
        self.assertIn('Invalid payment form', response.content)


    # Test that an error message is displayed when the payment amount is negative
    def test_negative_payment_amount_error_message_displayed(self):
        # Create a mock request object
        request = HttpRequest()
        request.user = User(type='Admin')
    
        # Create a mock response object
        response = HttpResponse()
    
        # Create an instance of PaymentView
        payment_view = PaymentView()
    
        # Set the request and response objects for the PaymentView instance
        payment_view.request = request
        payment_view.response = response
    
        # Set the payment amount to a negative value
        payment_view.payment_amount = -100
    
        # Call the handle_no_permission method of PaymentView
        payment_view.handle_no_permission()
    
        # Assert that the response status code is 403 (Forbidden)
        self.assertEqual(response.status_code, 403)
    
        # Assert that the response content contains the error message
        self.assertIn('Payment amount cannot be negative', response.content)


    # Test that when the payment form is valid but the payment processing fails, an error message is displayed.
    def test_payment_processing_failure(self):
        # Create a mock request object
        request = HttpRequest()
        request.user = User(type='Admin')
    
        # Create a mock payment form
        form = MockPaymentForm()
        form.is_valid.return_value = True
    
        # Create a mock template
        template = MockTemplate()
        template.render.return_value = '<html>Error message</html>'
    
        # Create an instance of PaymentView
        view = PaymentView()
        view.request = request
        view.get_template = lambda name: template
    
        # Call the handle_no_permission method
        response = view.handle_no_permission()
    
        # Assert that the response contains the error message
        self.assertIn('Error message', response.content)


    # Test that when a payment is processed successfully but the email notification fails, an error message is displayed.
    def test_payment_notification_failure(self):
        # Mock the request user
        user = User.objects.create(username='admin', type='Admin')
        request = RequestFactory().get('/')
        request.user = user

        # Mock the template rendering
        template = get_template('multitenancy/billing/payments.html')
        rendered_template = template.render({}, request=request)

        # Mock the email notification failure
        with patch('multitenancy.billing.views.send_email_notification') as mock_send_email:
            mock_send_email.side_effect = Exception('Email notification failed')

            # Make the request to the view
            response = self.client.get('/billing/payments/')

            # Assert that the payment was processed successfully
            self.assertEqual(response.status_code, 200)
            self.assertIn('Payment processed successfully', response.content.decode())

            # Assert that the error message is displayed
            self.assertIn('Email notification failed', response.content.decode())


    # Test that when the payment is processed successfully but the database connection fails, an error message is displayed.
    def test_payment_failure(self):
        # Mocking the request user
        user = User.objects.create(username='admin', type='Admin')
        request = RequestFactory().get('/')
        request.user = user

        # Mocking the template rendering
        template = get_template('multitenancy/billing/payments.html')
        rendered_template = template.render({}, request=request)

        # Mocking the database connection failure
        with patch('multitenancy.billing.models.Payment.objects.create') as mock_create_payment:
            mock_create_payment.side_effect = DatabaseError

            # Creating an instance of PaymentView and calling the get method
            view = PaymentView()
            response = view.get(request)

            # Asserting that the response contains the error message
            self.assertContains(response, 'Database connection failed')


    # Test that verifies if the payment is processed successfully but the payment confirmation email is not sent and no error message is displayed.
    def test_payment_confirmation_email_not_sent(self):
        # Create a mock request object
        request = HttpRequest()
        request.user = User.objects.create(type='Admin')
    
        # Create a mock response object
        response = HttpResponse()
    
        # Create an instance of PaymentView
        payment_view = PaymentView()
    
        # Set the request and response objects for the PaymentView instance
        payment_view.request = request
        payment_view.response = response
    
        # Call the handle_no_permission method of the PaymentView instance
        payment_view.handle_no_permission()
    
        # Assert that the response status code is 403 (Forbidden)
        self.assertEqual(response.status_code, 403)


    # Test that the payment confirmation email is sent to the spam folder and no error message is displayed when the payment is processed successfully.
    def test_payment_confirmation_email_sent_to_spam(self):
        # Simulate a successful payment
        payment = Payment()
        payment.process()

        # Check if the payment confirmation email is sent to the spam folder
        self.assertEqual(payment.confirmation_email.folder, 'spam')

        # Check if no error message is displayed
        self.assertNotIn('error', payment.response)



class TestInvoiceViewSet(unittest.TestCase):
    def setUp(self):
            self.factory = RequestFactory()
            self.client = Client()
    # Test that the 'get_queryset' method of the 'InvoiceViewSet' class returns a queryset of all invoices when no filters are applied.
    def test_retrieve_invoices_no_filters(self):
        # Create some invoices
        invoice1 = Invoice.objects.create()
        invoice2 = Invoice.objects.create()
    
        # Make a GET request to retrieve the list of invoices
        response = self.client.get('/invoices/')
    
        # Check that the response status code is 200 OK
        self.assertEqual(response.status_code, 200)
    
        # Check that the response data contains the correct number of invoices
        self.assertEqual(len(response.data), 2)
    
        # Check that the response data contains the correct invoice details
        self.assertEqual(response.data[0]['id'], invoice1.id)
        self.assertEqual(response.data[0]['subscription'], invoice1.subscription.id)
        self.assertEqual(response.data[0]['date_created'], invoice1.date_created)
        # ... continue checking other fields for invoice1
    
        self.assertEqual(response.data[1]['id'], invoice2.id)
        self.assertEqual(response.data[1]['subscription'], invoice2.subscription.id)
        self.assertEqual(response.data[1]['date_created'], invoice2.date_created)
        # ... continue checking other fields for invoice2


    # Test that a new invoice is created successfully
    def test_create_new_invoice(self):
        # Create a new invoice
        invoice_data = {
            "subscription": 1,
            "due_date": "2022-01-01",
            "invoice_number": "INV001",
            "amount": 100.00,
            "credit_used": 0.00,
            "payment_method": "Credit Card",
            "status": "unpaid",
            "notes": "",
            "pdf": None
        }
        response = self.client.post('/invoices/', invoice_data)
    
        # Assert that the response status code is 201 (Created)
        self.assertEqual(response.status_code, 201)
    
        # Assert that the invoice is created in the database
        invoice = Invoice.objects.get(invoice_number="INV001")
        self.assertEqual(invoice.subscription.id, 1)
        self.assertEqual(invoice.due_date, datetime.date(2022, 1, 1))
        self.assertEqual(invoice.amount, 100.00)
        self.assertEqual(invoice.credit_used, 0.00)
        self.assertEqual(invoice.payment_method, "Credit Card")
        self.assertEqual(invoice.status, "unpaid")
        self.assertEqual(invoice.notes, "")
        self.assertIsNone(invoice.pdf)


    # Test that the 'retrieve' action of the InvoiceViewSet returns the correct invoice when given an ID
    def test_retrieve_single_invoice_by_id(self):
        # Create a sample invoice
        invoice = Invoice.objects.create(
            subscription=Subscription.objects.create(),
            due_date=datetime.date.today(),
            invoice_number="INV001",
            amount=100.00,
            payment_method="Credit Card",
            status="unpaid",
            notes="Sample invoice",
            pdf="invoice.pdf"
        )
    
        # Make a GET request to retrieve the invoice by ID
        response = self.client.get(f"/invoices/{invoice.id}/")
    
        # Assert that the response status code is 200 (OK)
        self.assertEqual(response.status_code, 200)
    
        # Assert that the retrieved invoice matches the created invoice
        self.assertEqual(response.data["id"], invoice.id)
        self.assertEqual(response.data["subscription"], invoice.subscription.id)
        self.assertEqual(response.data["due_date"], invoice.due_date.isoformat())
        self.assertEqual(response.data["invoice_number"], invoice.invoice_number)
        self.assertEqual(response.data["amount"], str(invoice.amount))
        self.assertEqual(response.data["payment_method"], invoice.payment_method)
        self.assertEqual(response.data["status"], invoice.status)
        self.assertEqual(response.data["notes"], invoice.notes)
        self.assertEqual(response.data["pdf"], invoice.pdf.url)


    # Test that the update action on the InvoiceViewSet class updates an existing invoice correctly.
    def test_update_existing_invoice(self):
        # Create a new invoice
        invoice = Invoice.objects.create(subscription=subscription, due_date=date.today(), invoice_number="INV001", amount=100.00, payment_method="Credit Card", status="unpaid")
    
        # Update the invoice
        updated_data = {
            "due_date": date.today() + timedelta(days=7),
            "amount": 150.00,
            "status": "paid"
        }
        response = self.client.put(f"/invoices/{invoice.id}/", updated_data)
    
        # Check that the invoice was updated correctly
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["due_date"], updated_data["due_date"].isoformat())
        self.assertEqual(response.data["amount"], str(updated_data["amount"]))
        self.assertEqual(response.data["status"], updated_data["status"])


    # Test that an invoice is successfully deleted
    def test_delete_invoice(self):
        # Create a new invoice
        invoice = Invoice.objects.create(...)
    
        # Delete the invoice
        response = self.client.delete(f'/invoices/{invoice.id}/')
    
        # Check that the invoice is deleted
        self.assertEqual(response.status_code, 204)
        self.assertFalse(Invoice.objects.filter(id=invoice.id).exists())


    # Test that the queryset is empty when filtering invoices by an invalid query parameter
    def test_invalid_query_parameter(self):
        # Create a request with an invalid query parameter
        request = RequestFactory().get('/invoices/?invalid_param=value')
        view = InvoiceViewSet()
        view.request = request

        # Call the get_queryset method
        queryset = view.get_queryset()

        # Assert that the queryset is empty
        self.assertEqual(len(queryset), 0)


    # Test that the queryset is empty when filtering invoices by an invalid date format
    def test_invalid_date_format(self):
        # Create a request with an invalid date format
        request = RequestFactory().get('/invoices/?due_date=2022-13-01')
        view = InvoiceViewSet()
        view.request = request

        # Call the get_queryset method
        queryset = view.get_queryset()

        # Assert that the queryset is empty
        self.assertEqual(len(queryset), 0)


    # Test that the queryset returned by the get_queryset method of InvoiceViewSet does not contain any invoices with an invalid status value
    def test_filtering_invoices_by_invalid_status_value(self):
        # Create a mock request object
        request = Mock()
        request.GET = {
            "status": "invalid_status"
        }
    
        # Create an instance of InvoiceViewSet
        invoice_viewset = InvoiceViewSet()
        invoice_viewset.request = request
    
        # Call the get_queryset method
        queryset = invoice_viewset.get_queryset()
    
        # Assert that the queryset does not contain any invoices with an invalid status value
        for invoice in queryset:
            self.assertNotEqual(invoice.status, "invalid_status")


    # Test that attempting to retrieve a non-existent invoice returns a 404 status code
    def test_retrieve_nonexistent_invoice(self):
        # Create a request with a non-existent invoice ID
        request = self.client.get('/invoices/9999/')
    
        # Send the request and get the response
        response = self.client.get(request)
    
        # Assert that the response status code is 404
        self.assertEqual(response.status_code, 404)


    # Test that attempting to update a non-existent invoice returns a 404 status code
    def test_update_nonexistent_invoice(self):
        # Create a new invoice
        invoice = Invoice.objects.create(subscription=subscription, due_date=date.today(), invoice_number="INV001", amount=100.00, payment_method="Credit Card", status="unpaid")
    
        # Attempt to update the invoice with a non-existent id
        response = self.client.put(f"/invoices/{invoice.id + 1}/", data={"status": "paid"})
    
        # Assert that the response status code is 404
        self.assertEqual(response.status_code, 404)


    # Test that the queryset returned by the get_queryset method of InvoiceViewSet filters invoices based on a valid query parameter
    def test_filter_invoices_by_valid_query_parameter(self):
        # Create a valid query parameter
        query_param = "example_query"
    
        # Create a mock request object with the valid query parameter
        request = Mock()
        request.GET.get.return_value = query_param
    
        # Create an instance of InvoiceViewSet
        invoice_viewset = InvoiceViewSet()
        invoice_viewset.request = request
    
        # Call the get_queryset method
        queryset = invoice_viewset.get_queryset()
    
        # Assert that the queryset is filtered based on the valid query parameter
        expected_queryset = Invoice.objects.filter().search(query=query_param).filter_by_id(id=None).get_due_date(date=None).filter_date_range(start_date=None, end_date=None).get_status(status=None)
        self.assertEqual(queryset, expected_queryset)


    # Test that the 'list' action of the InvoiceViewSet retrieves a paginated list of invoices
    def test_retrieve_invoices_with_pagination(self):
        # Create some test invoices
        invoice1 = Invoice.objects.create(...)
        invoice2 = Invoice.objects.create(...)
        invoice3 = Invoice.objects.create(...)
    
        # Make a GET request to retrieve the list of invoices
        response = self.client.get('/invoices/')
    
        # Assert that the response status code is 200 (OK)
        self.assertEqual(response.status_code, 200)
    
        # Assert that the response data contains the expected number of invoices
        self.assertEqual(len(response.data), 3)
    
        # Assert that the response data is paginated
        self.assertIn('results', response.data)
        self.assertIn('count', response.data)
        self.assertIn('next', response.data)
        self.assertIn('previous', response.data)


    # Test that the 'get_queryset' method of the 'InvoiceViewSet' class correctly filters invoices by status.
    def test_filter_invoices_by_status(self):
        # Create some test data
        invoice1 = Invoice.objects.create(invoice_number="INV001", status="paid")
        invoice2 = Invoice.objects.create(invoice_number="INV002", status="unpaid")
        invoice3 = Invoice.objects.create(invoice_number="INV003", status="pending")
    
        # Set the request parameters
        self.request.GET = {
            "status": "paid"
        }
    
        # Call the 'get_queryset' method
        queryset = InvoiceViewSet.get_queryset(self)
    
        # Check that only the invoices with status "paid" are returned
        self.assertEqual(list(queryset), [invoice1])


    # Test that the get_queryset method of the InvoiceViewSet class correctly filters the queryset based on the provided keyword
    def test_search_invoices_by_keyword(self):
        # Create some test invoices
        invoice1 = Invoice.objects.create(invoice_number="INV001", amount=100)
        invoice2 = Invoice.objects.create(invoice_number="INV002", amount=200)
        invoice3 = Invoice.objects.create(invoice_number="INV003", amount=300)
    
        # Set the request GET parameters
        self.request.GET = {
            "q": "INV002"  # Search for invoices with invoice_number containing "INV002"
        }
    
        # Call the get_queryset method
        queryset = InvoiceViewSet.get_queryset(self)
    
        # Assert that only invoice2 is returned in the queryset
        self.assertEqual(list(queryset), [invoice2])


    # Test that the 'get_queryset' method of the 'InvoiceViewSet' class returns the correct invoice when searching by ID.
    def test_get_invoice_by_id(self):
        # Create a sample invoice
        invoice = Invoice.objects.create(
            subscription=Subscription.objects.create(),
            date_created=datetime.date.today(),
            due_date=datetime.date.today() + datetime.timedelta(days=30),
            invoice_number="INV001",
            amount=100.00,
            credit_used=0.00,
            payment_method="Credit Card",
            status="unpaid",
            notes="",
            pdf=None
        )
    
        # Set the request parameters
        self.request.GET = {
            "id": invoice.id
        }
    
        # Create an instance of the InvoiceViewSet class
        viewset = InvoiceViewSet()
    
        # Call the get_queryset method
        queryset = viewset.get_queryset()
    
        # Assert that the queryset contains only the expected invoice
        self.assertEqual(len(queryset), 1)
        self.assertEqual(queryset[0], invoice)



class TestRefundViewSet(unittest.TestCase):
    def setUp(self):
            self.factory = RequestFactory()
            self.client = Client()
    # Test that the 'get_queryset' method of the 'RefundViewSet' class retrieves a list of refunds based on the provided query parameter
    def test_retrieve_list_of_refunds(self):
        # Create a mock request object with a query parameter
        request = Mock()
        request.GET.get.return_value = "123"  # Assuming the query parameter is '123'
    
        # Create a mock queryset
        queryset = Mock()
        Refund.objects.filter().get_invoice.return_value = queryset
    
        # Create an instance of the RefundViewSet class
        viewset = RefundViewSet()
        viewset.request = request
    
        # Call the get_queryset method
        result = viewset.get_queryset()
    
        # Assert that the get_invoice method was called with the correct invoice_id parameter
        Refund.objects.filter().get_invoice.assert_called_with(invoice_id="123")
    
        # Assert that the result is equal to the mock queryset
        self.assertEqual(result, queryset)


    # Test that a new refund can be created
    def test_create_new_refund(self):
        # Create a new refund
        refund_data = {
            "invoice": 1,
            "amount": 100.00,
            "date": "2022-01-01T00:00:00Z",
            "reason": "Test refund"
        }
        response = self.client.post('/refunds/', refund_data)
    
        # Assert that the refund was created successfully
        self.assertEqual(response.status_code, 201)
        self.assertEqual(Refund.objects.count(), 1)
        self.assertEqual(Refund.objects.first().amount, 100.00)
        self.assertEqual(Refund.objects.first().reason, "Test refund")


    # Test that the 'retrieve' action of the RefundViewSet returns the specific refund requested
    def test_retrieve_specific_refund(self):
        # Create a refund object
        refund = Refund.objects.create(invoice=Invoice.objects.create(), amount=100, reason="Test refund")
    
        # Set up the request
        request = self.client.get(f"/refunds/{refund.pk}/")
    
        # Make the request
        response = RefundViewSet.as_view({"get": "retrieve"})(request, pk=refund.pk)
    
        # Check the response status code
        self.assertEqual(response.status_code, 200)
    
        # Check that the returned refund matches the created refund
        self.assertEqual(response.data["invoice"]["id"], refund.invoice.pk)
        self.assertEqual(response.data["amount"], refund.amount)
        self.assertEqual(response.data["reason"], refund.reason)


    # Test that the update_refund function updates the refund correctly
    def test_update_refund(self):
        # Create a refund object
        refund = Refund.objects.create(invoice=Invoice.objects.create(), amount=100, date=datetime.now(), reason="Test refund")
    
        # Update the refund
        updated_amount = 200
        refund.amount = updated_amount
        refund.save()
    
        # Retrieve the updated refund from the database
        updated_refund = Refund.objects.get(pk=refund.pk)
    
        # Check if the amount is updated correctly
        self.assertEqual(updated_refund.amount, updated_amount)


    # Test that a refund is successfully deleted
    def test_delete_refund(self):
        # Create a refund object
        refund = Refund.objects.create(invoice=Invoice.objects.create(), amount=100, date=datetime.now(), reason="Test refund")
    
        # Get the initial count of refunds
        initial_count = Refund.objects.count()
    
        # Delete the refund
        response = self.client.delete(f"/refunds/{refund.pk}/")
    
        # Check that the refund is deleted
        self.assertEqual(response.status_code, 204)
        self.assertEqual(Refund.objects.count(), initial_count - 1)


    # Test that the RefundViewSet filters refunds by a non-existent invoice ID and returns an empty queryset.
    def test_filter_refunds_nonexistent_invoice_id(self):
        # Create a non-existent invoice ID
        invoice_id = 9999
    
        # Make a GET request to the RefundViewSet with the non-existent invoice ID
        response = self.client.get(f"/refunds/?q={invoice_id}")
    
        # Assert that the response status code is 200 (OK)
        self.assertEqual(response.status_code, 200)
    
        # Assert that the response data is an empty list
        self.assertEqual(response.data, [])


    # Test that the RefundViewSet filters refunds correctly when given an invalid query parameter.
    def test_invalid_query_parameter(self):
        # Create a mock request with an invalid query parameter
        request = Mock()
        request.GET.get.return_value = "invalid_query"
    
        # Create an instance of RefundViewSet
        view = RefundViewSet()
        view.request = request
    
        # Call the get_queryset method
        queryset = view.get_queryset()
    
        # Assert that the queryset is empty
        self.assertEqual(queryset.count(), 0)


    # Test that a refund with a negative amount can be created
    def test_create_refund_with_negative_amount(self):
        # Create a refund with a negative amount
        refund_data = {
            "invoice": 1,
            "amount": -100.00,
            "date": "2022-01-01T00:00:00Z",
            "reason": "Negative amount refund"
        }
        response = self.client.post("/refunds/", refund_data)
    
        # Assert that the refund was created successfully
        self.assertEqual(response.status_code, 201)
        self.assertEqual(Refund.objects.count(), 1)
        refund = Refund.objects.first()
        self.assertEqual(refund.amount, -100.00)
        self.assertEqual(refund.reason, "Negative amount refund")


    # Test that updating a refund with an invalid invoice ID raises an error
    def test_update_refund_with_invalid_invoice_id(self):
        # Create a refund
        refund = Refund.objects.create(invoice_id=1, amount=100, date=datetime.now(), reason="Test refund")
    
        # Attempt to update the refund with an invalid invoice ID
        with self.assertRaises(Invoice.DoesNotExist):
            refund.invoice_id = 2
            refund.save()


    # Test that deleting a non-existent refund returns a 404 status code
    def test_delete_nonexistent_refund(self):
        # Create a mock request object
        request = type('Request', (object,), {'GET': {'q': 'nonexistent'}})()
    
        # Create a mock viewset object
        viewset = RefundViewSet()
        viewset.request = request
    
        # Call the get_queryset method
        queryset = viewset.get_queryset()
    
        # Assert that the queryset is empty
        self.assertEqual(queryset.count(), 0)
    
        # Call the destroy method with a non-existent refund id
        response = viewset.destroy(request, pk=1)
    
        # Assert that the response status code is 404
        self.assertEqual(response.status_code, 404)


    # Test that the RefundViewSet filters refunds correctly when given an invoice ID that has no refunds
    def test_filter_refunds_no_refunds(self):
        # Create an invoice with no refunds
        invoice = Invoice.objects.create()
    
        # Set the invoice ID in the request GET parameters
        self.request.GET = {'q': invoice.id}
    
        # Call the get_queryset method of RefundViewSet
        queryset = RefundViewSet.get_queryset(self)
    
        # Assert that the queryset is empty
        self.assertEqual(queryset.count(), 0)


    # Test that the RefundViewSet filters refunds by an invoice ID that has multiple refunds
    def test_filter_refunds_by_invoice_id_with_multiple_refunds(self):
        # Create an invoice with multiple refunds
        invoice = Invoice.objects.create()
        refund1 = Refund.objects.create(invoice=invoice, amount=10.00, reason="Reason 1")
        refund2 = Refund.objects.create(invoice=invoice, amount=20.00, reason="Reason 2")
        refund3 = Refund.objects.create(invoice=invoice, amount=30.00, reason="Reason 3")
    
        # Set the query parameter to the invoice ID
        self.request.GET = {"q": invoice.id}
    
        # Call the get_queryset method of RefundViewSet
        queryset = RefundViewSet.get_queryset(self)
    
        # Assert that the queryset contains all the refunds for the given invoice ID
        self.assertEqual(list(queryset), [refund1, refund2, refund3])


    # Test that a refund with a zero amount can be created
    def test_create_refund_with_zero_amount(self):
        # Create a refund with a zero amount
        refund_data = {
            "invoice": 1,
            "amount": 0,
            "date": "2022-01-01T00:00:00Z",
            "reason": "Zero amount refund"
        }
        response = self.client.post("/refunds/", refund_data)
    
        # Assert that the refund was created successfully
        self.assertEqual(response.status_code, 201)
        self.assertEqual(Refund.objects.count(), 1)
        refund = Refund.objects.first()
        self.assertEqual(refund.amount, 0)


    # Test that a refund can be updated with a zero amount
    def test_update_refund_with_zero_amount(self):
        # Create a refund with a non-zero amount
        refund = Refund.objects.create(invoice=Invoice.objects.create(), amount=100.00, reason="Test refund")
    
        # Update the refund with a zero amount
        response = self.client.put(f"/refunds/{refund.pk}/", data={"amount": 0.00})
    
        # Check that the refund was updated successfully
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["amount"], 0.00)
        self.assertEqual(Refund.objects.get(pk=refund.pk).amount, 0.00)


    # Test that the refund is updated with a different invoice ID
    def test_update_refund_with_different_invoice_id(self):
        # Create a refund
        refund = Refund.objects.create(invoice=Invoice.objects.create(), amount=100, date=datetime.now(), reason="Test refund")
    
        # Create a new invoice
        new_invoice = Invoice.objects.create()
    
        # Update the refund with the new invoice ID
        refund.invoice = new_invoice
        refund.save()
    
        # Retrieve the updated refund from the database
        updated_refund = Refund.objects.get(pk=refund.pk)
    
        # Assert that the refund's invoice ID is equal to the new invoice ID
        self.assertEqual(updated_refund.invoice.pk, new_invoice.pk)



class TestCreditViewSet(unittest.TestCase):
    def setUp(self):
            self.factory = RequestFactory()
            self.client = Client()
    # Test that the GET request returns a list of credits for a specific customer
    def test_get_credits_for_customer(self):
        # Create a customer and credits
        customer = User.objects.create(username='testuser')
        credit1 = Credit.objects.create(customer=customer, amount=100)
        credit2 = Credit.objects.create(customer=customer, amount=200)
    
        # Make a GET request to retrieve the credits for the customer
        response = self.client.get(f'/credits/?q={customer.id}')
    
        # Check that the response status code is 200 OK
        self.assertEqual(response.status_code, 200)
    
        # Check that the response data contains the correct credits
        self.assertEqual(response.data, [
            {'id': credit1.id, 'customer': customer.id, 'amount': '100.00'},
            {'id': credit2.id, 'customer': customer.id, 'amount': '200.00'}
        ])


    # Test that a POST request creates a new credit for a customer
    def test_create_new_credit(self):
        # Create a mock request object
        request = self.client.post('/credits/', {'customer': 1, 'amount': 100.00})
    
        # Check that the response status code is 201 (created)
        self.assertEqual(request.status_code, 201)
    
        # Check that a new credit object was created in the database
        self.assertEqual(Credit.objects.count(), 1)
    
        # Check that the customer ID and amount are correct
        credit = Credit.objects.first()
        self.assertEqual(credit.customer_id, 1)
        self.assertEqual(credit.amount, 100.00)


    # Test that a PUT request updates an existing credit for a customer
    def test_update_existing_credit(self):
        # Create a user and credit object
        user = User.objects.create(username='testuser')
        credit = Credit.objects.create(customer=user, amount=100)
    
        # Make a PUT request to update the credit
        url = f'/credits/{credit.id}/'
        data = {'amount': 200}
        response = self.client.put(url, data, format='json')
    
        # Check that the credit was updated
        updated_credit = Credit.objects.get(id=credit.id)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(updated_credit.amount, 200)


    # Test that a DELETE request deletes an existing credit for a customer
    def test_delete_existing_credit(self):
        # Create a credit object
        credit = Credit.objects.create(customer_id=1, amount=100)
    
        # Send a DELETE request to delete the credit
        response = self.client.delete(f"/credits/{credit.id}/")
    
        # Check that the credit is deleted
        self.assertEqual(response.status_code, 204)
        self.assertFalse(Credit.objects.filter(id=credit.id).exists())


    # Test that a GET request returns an empty list when no credits exist for a customer
    def test_empty_credit_list(self):
        # Create a customer
        customer = User.objects.create(username='testuser')
    
        # Make a GET request with the customer's ID
        response = self.client.get(f'/credits/?q={customer.id}')
    
        # Check that the response status code is 200 OK
        self.assertEqual(response.status_code, 200)
    
        # Check that the response data is an empty list
        self.assertEqual(response.data, [])


    # Test that a POST request returns a 400 Bad Request status code when required fields are missing
    def test_missing_required_fields(self):
        # Create a client
        client = APIClient()
    
        # Make a POST request without the required fields
        response = client.post('/credits/', {})
    
        # Assert that the response status code is 400 Bad Request
        self.assertEqual(response.status_code, 400)


    # Test that a PUT request returns a 404 Not Found status code when the credit does not exist for a customer.
    def test_put_request_returns_404_not_found(self):
        # Create a customer
        customer = User.objects.create(username='testuser')
    
        # Create a credit for the customer
        credit = Credit.objects.create(customer=customer, amount=100)
    
        # Make a PUT request to update the credit with a non-existing customer ID
        response = self.client.put(f'/credits/{credit.id}/', data={'customer': 9999, 'amount': 200})
    
        # Assert that the response status code is 404 Not Found
        self.assertEqual(response.status_code, 404)
    
        # Assert that the credit was not updated
        credit.refresh_from_db()
        self.assertEqual(credit.amount, 100)


    # Test that a DELETE request returns a 404 Not Found status code when the credit does not exist for a customer.
    def test_delete_request_returns_404_not_found_when_credit_does_not_exist(self):
        # Create a customer
        customer = User.objects.create(username='testuser')
    
        # Create a credit for the customer
        credit = Credit.objects.create(customer=customer, amount=100)
    
        # Make a DELETE request to delete the credit
        response = self.client.delete(f'/credits/{credit.id}/')
    
        # Assert that the response status code is 404 Not Found
        self.assertEqual(response.status_code, 404)
    
        # Assert that the credit still exists in the database
        self.assertTrue(Credit.objects.filter(id=credit.id).exists())
    
        # Assert that the credit is still associated with the customer
        self.assertEqual(credit.customer, customer)


    # Test that a GET request with an invalid customer ID returns a 400 Bad Request response.
    def test_invalid_customer_id_returns_bad_request(self):
        # Create a mock request object
        request = MagicMock()
        request.GET.get.return_value = "invalid_id"
    
        # Create a mock viewset object
        viewset = CreditViewSet()
        viewset.request = request
    
        # Call the get_queryset method
        queryset = viewset.get_queryset()
    
        # Assert that the queryset is empty
        self.assertEqual(queryset.count(), 0)
    
        # Assert that the response status code is 400
        response = viewset.list(request)
        self.assertEqual(response.status_code, 400)


    # Test that a GET request with a non-existent customer ID returns a 404 Not Found status code
    def test_nonexistent_customer_id_returns_404(self):
        # Create a mock request object with a non-existent customer ID
        request = type('Request', (object,), {'GET': {'q': 'nonexistent_customer_id'}})()
    
        # Create an instance of the CreditViewSet class
        view = CreditViewSet()
    
        # Set the request attribute of the view to the mock request object
        view.request = request
    
        # Call the get_queryset method of the view
        queryset = view.get_queryset()
    
        # Assert that the queryset is empty
        self.assertEqual(queryset.count(), 0)
    
        # Assert that the status code of the response is 404
        self.assertEqual(view.response.status_code, 404)


    # Test that a GET request with an invalid query parameter returns a 400 Bad Request status code.
    def test_invalid_query_parameter_returns_400(self):
        # Create a mock request object with an invalid query parameter
        request = Mock()
        request.GET = {'q': 'invalid'}

        # Create an instance of the CreditViewSet class
        view = CreditViewSet()

        # Set the request attribute of the view to the mock request object
        view.request = request

        # Call the get_queryset method of the view
        queryset = view.get_queryset()

        # Assert that the queryset is empty
        self.assertEqual(queryset.count(), 0)

        # Assert that the status code of the response is 400
        self.assertEqual(view.response.status_code, 400)


    # Test that a POST request with an invalid customer ID returns a 400 Bad Request status code.
    def test_invalid_customer_id_returns_bad_request(self):
        # Create a mock request object
        request = MagicMock()
        request.method = 'POST'
        request.GET.get.return_value = None
    
        # Create a mock viewset object
        viewset = CreditViewSet()
        viewset.request = request
    
        # Call the get_queryset method
        queryset = viewset.get_queryset()
    
        # Assert that the queryset is empty
        self.assertEqual(queryset.count(), 0)
    
        # Assert that the response status code is 400
        response = viewset.create(request)
        self.assertEqual(response.status_code, 400)


    # Test that a PUT request with an invalid customer ID returns a 400 Bad Request status code.
    def test_invalid_customer_id_returns_400(self):
        # Create a mock request object
        request = MagicMock()
        request.GET.get.return_value = "invalid_customer_id"
    
        # Create a mock viewset object
        viewset = CreditViewSet()
        viewset.request = request
    
        # Call the get_queryset method
        queryset = viewset.get_queryset()
    
        # Assert that the queryset is empty
        self.assertEqual(queryset.count(), 0)
    
        # Assert that the response status code is 400
        response = viewset.put(request)
        self.assertEqual(response.status_code, 400)



class TestPaymentGateWayViewSet(unittest.TestCase):
    def setUp(self):
            self.factory = RequestFactory()
            self.client = Client()
    # Test that the 'list' action of the PaymentGateWayViewSet retrieves all payment gateways
    def test_retrieve_all_payment_gateways(self):
        # Create some payment gateways
        payment_gateway1 = PaymentGateWay.objects.create(name="Gateway 1", description="Description 1", status="active", default=False)
        payment_gateway2 = PaymentGateWay.objects.create(name="Gateway 2", description="Description 2", status="inactive", default=True)
    
        # Make a GET request to retrieve all payment gateways
        response = self.client.get('/payment-gateways/')
    
        # Check that the response status code is 200 (OK)
        self.assertEqual(response.status_code, 200)
    
        # Check that the response data contains the created payment gateways
        self.assertIn(payment_gateway1.name, response.data)
        self.assertIn(payment_gateway2.name, response.data)


    # Test that a new payment gateway can be created
    def test_create_payment_gateway(self):
        # Create a new payment gateway
        payment_gateway_data = {
            'name': 'Test Gateway',
            'description': 'Test Description',
            'status': 'active',
            'default': False
        }
        response = self.client.post('/payment-gateways/', payment_gateway_data)
    
        # Assert that the payment gateway was created successfully
        self.assertEqual(response.status_code, 201)
        self.assertEqual(PaymentGateWay.objects.count(), 1)
        payment_gateway = PaymentGateWay.objects.first()
        self.assertEqual(payment_gateway.name, 'Test Gateway')
        self.assertEqual(payment_gateway.description, 'Test Description')
        self.assertEqual(payment_gateway.status, 'active')
        self.assertEqual(payment_gateway.default, False)


    # Test that the retrieve action of the PaymentGateWayViewSet returns the correct payment gateway
    def test_retrieve_specific_payment_gateway(self):
        # Create a payment gateway
        payment_gateway = PaymentGateWay.objects.create(name="Test Gateway", description="Test Description", status="active", default=False)
    
        # Retrieve the payment gateway using the viewset
        response = self.client.get(f"/payment-gateways/{payment_gateway.id}/")
    
        # Check that the response status code is 200 (OK)
        self.assertEqual(response.status_code, 200)
    
        # Check that the retrieved payment gateway matches the created payment gateway
        self.assertEqual(response.data["name"], payment_gateway.name)
        self.assertEqual(response.data["description"], payment_gateway.description)
        self.assertEqual(response.data["status"], payment_gateway.status)
        self.assertEqual(response.data["default"], payment_gateway.default)


    # Test that the update action on the PaymentGateWayViewSet updates a payment gateway correctly.
    def test_update_payment_gateway(self):
        # Create a payment gateway
        payment_gateway = PaymentGateWay.objects.create(name="Test Gateway", description="Test Description", status="active", default=False)
    
        # Update the payment gateway
        updated_data = {
            "name": "Updated Gateway",
            "description": "Updated Description",
            "status": "inactive",
            "default": True
        }
        response = self.client.put(f"/payment-gateways/{payment_gateway.id}/", data=updated_data)
    
        # Check that the payment gateway was updated correctly
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["name"], "Updated Gateway")
        self.assertEqual(response.data["description"], "Updated Description")
        self.assertEqual(response.data["status"], "inactive")
        self.assertEqual(response.data["default"], True)


    # Test that a payment gateway is successfully deleted
    def test_delete_payment_gateway(self):
        # Create a payment gateway
        payment_gateway = PaymentGateWay.objects.create(name="Test Gateway", description="Test Description", status="active", default=False)
    
        # Delete the payment gateway
        response = self.client.delete(f"/payment-gateways/{payment_gateway.id}/")
    
        # Check that the payment gateway is deleted
        self.assertEqual(response.status_code, 204)
        self.assertFalse(PaymentGateWay.objects.filter(id=payment_gateway.id).exists())


    # Test that creating a payment gateway with a name that already exists raises an error
    def test_create_duplicate_payment_gateway(self):
        # Create a payment gateway with a unique name
        payment_gateway = PaymentGateWay.objects.create(name="Test Gateway", description="Test Description", status="active", default=False)
    
        # Try to create another payment gateway with the same name
        with self.assertRaises(Exception):
            PaymentGateWay.objects.create(name="Test Gateway", description="Test Description", status="active", default=False)


    # Test that updating a payment gateway with a name that already exists raises an error
    def test_update_payment_gateway_with_existing_name(self):
        # Create a payment gateway with a unique name
        payment_gateway1 = PaymentGateWay.objects.create(name="Gateway 1", description="Description 1", status="active", default=False)
    
        # Create another payment gateway with a unique name
        payment_gateway2 = PaymentGateWay.objects.create(name="Gateway 2", description="Description 2", status="active", default=False)
    
        # Try to update payment_gateway2 with the name of payment_gateway1
        data = {
            "name": "Gateway 1",
            "description": "Updated description",
            "status": "inactive",
            "default": True
        }
        serializer = PaymentGatewaySerializer(payment_gateway2, data=data)
        self.assertFalse(serializer.is_valid())
        self.assertEqual(serializer.errors["name"][0], "Payment gateway with this name already exists.")


    # Test that deleting a payment gateway that is the default gateway raises an exception
    def test_delete_default_gateway(self):
        # Create a default payment gateway
        default_gateway = PaymentGateWay.objects.create(name="Default Gateway", description="Default gateway", status="active", default=True)
    
        # Try to delete the default gateway
        response = self.client.delete(f"/payment_gateways/{default_gateway.id}/")
    
        # Check that the response status code is 400 (Bad Request)
        self.assertEqual(response.status_code, 400)
    
        # Check that the default gateway still exists in the database
        self.assertTrue(PaymentGateWay.objects.filter(id=default_gateway.id).exists())


    # Test that updating a payment gateway to make it the default gateway when another default gateway already exists raises an exception.
    def test_update_default_gateway_with_existing_default(self):
        # Create a default payment gateway
        default_gateway = PaymentGateWay.objects.create(name="Default Gateway", description="Default Gateway", status="active", default=True)
    
        # Create another payment gateway
        gateway = PaymentGateWay.objects.create(name="Gateway", description="Gateway", status="active", default=False)
    
        # Try to update the gateway to make it the default gateway
        gateway.default = True
    
        # Assert that updating the gateway raises an exception
        with self.assertRaises(Exception):
            gateway.save()


    # Test that only authenticated users can access the viewset
    def test_authenticated_users_access_viewset(self):
        # Create a user and authenticate
        user = User.objects.create_user(username='testuser', password='testpassword')
        self.client.force_authenticate(user=user)
    
        # Make a GET request to the viewset
        response = self.client.get('/payment-gateways/')
    
        # Assert that the response status code is 200 (OK)
        self.assertEqual(response.status_code, 200)
    
        # Assert that the response contains the expected data
        expected_data = [
            {
                'id': 1,
                'name': 'Payment Gateway 1',
                'description': 'Description of Payment Gateway 1',
                'status': 'active',
                'default': False
            },
            {
                'id': 2,
                'name': 'Payment Gateway 2',
                'description': 'Description of Payment Gateway 2',
                'status': 'inactive',
                'default': True
            }
        ]
        self.assertEqual(response.data, expected_data)
    
        # Logout the user
        self.client.logout()
    
        # Make a GET request to the viewset
        response = self.client.get('/payment-gateways/')
    
        # Assert that the response status code is 403 (Forbidden)
        self.assertEqual(response.status_code, 403)


    # Test that only admin users can create, update, and delete payment gateways
    def test_admin_permissions(self):
        # Create a regular user
        regular_user = User.objects.create_user(username='regular_user', password='password')
    
        # Create an admin user
        admin_user = User.objects.create_user(username='admin_user', password='password')
        admin_user.is_staff = True
        admin_user.save()
    
        # Authenticate as the regular user
        self.client.login(username='regular_user', password='password')
    
        # Test that regular user cannot create a payment gateway
        response = self.client.post('/payment_gateways/', {'name': 'Test Gateway', 'description': 'Test Description', 'status': 'active', 'default': False})
        self.assertEqual(response.status_code, 403)
    
        # Test that regular user cannot update a payment gateway
        payment_gateway = PaymentGateWay.objects.create(name='Test Gateway', description='Test Description', status='active', default=False)
        response = self.client.put(f'/payment_gateways/{payment_gateway.id}/', {'name': 'Updated Gateway'})
        self.assertEqual(response.status_code, 403)
    
        # Test that regular user cannot delete a payment gateway
        response = self.client.delete(f'/payment_gateways/{payment_gateway.id}/')
        self.assertEqual(response.status_code, 403)
    
        # Authenticate as the admin user
        self.client.login(username='admin_user', password='password')
    
        # Test that admin user can create a payment gateway
        response = self.client.post('/payment_gateways/', {'name': 'Test Gateway', 'description': 'Test Description', 'status': 'active', 'default': False})
        self.assertEqual(response.status_code, 201)
    
        # Test that admin user can update a payment gateway
        response = self.client.put(f'/payment_gateways/{payment_gateway.id}/', {'name': 'Updated Gateway'})
        self.assertEqual(response.status_code, 200)
    
        # Test that admin user can delete a payment gateway
        response = self.client.delete(f'/payment_gateways/{payment_gateway.id}/')
        self.assertEqual(response.status_code, 204)


    # Test that the serializer returns the expected fields and values
    def test_serializer_fields_and_values(self):
        # Create a PaymentGateWay object
        payment_gateway = PaymentGateWay.objects.create(
            name="Test Gateway",
            description="Test Description",
            status="active",
            default=True
        )
    
        # Serialize the PaymentGateWay object
        serializer = PaymentGatewaySerializer(payment_gateway)
    
        # Verify that the serialized data has the expected fields and values
        self.assertEqual(serializer.data['name'], "Test Gateway")
        self.assertEqual(serializer.data['description'], "Test Description")
        self.assertEqual(serializer.data['status'], "active")
        self.assertEqual(serializer.data['default'], True)


    # Test that the status field can only be set to "active" or "inactive"
    def test_status_field(self):
        # Create a PaymentGateWay object with a valid status
        payment_gateway = PaymentGateWay.objects.create(name="Test Gateway", description="Test Description", status="active", default=False)
    
        # Verify that the object was created successfully
        self.assertEqual(payment_gateway.status, "active")
    
        # Try to create a PaymentGateWay object with an invalid status
        with self.assertRaises(ValueError):
            PaymentGateWay.objects.create(name="Invalid Gateway", description="Invalid Description", status="invalid", default=False)


    # Test that the default field can only be set to True for one payment gateway at a time
    def test_default_field_unique(self):
        # Create two payment gateways with default set to True
        payment_gateway1 = PaymentGateWay.objects.create(name="Gateway 1", description="Description 1", status="active", default=True)
        payment_gateway2 = PaymentGateWay.objects.create(name="Gateway 2", description="Description 2", status="active", default=True)
    
        # Check that the default field of the first payment gateway is True
        self.assertTrue(payment_gateway1.default)
    
        # Check that the default field of the second payment gateway is False
        self.assertFalse(payment_gateway2.default)
    
        # Update the default field of the second payment gateway to True
        payment_gateway2.default = True
        payment_gateway2.save()
    
        # Check that the default field of the first payment gateway is now False
        self.assertFalse(payment_gateway1.default)
    
        # Check that the default field of the second payment gateway is still True
        self.assertTrue(payment_gateway2.default)



class TestPaymentViewSet(unittest.TestCase):
    def setUp(self):
            self.factory = RequestFactory()
            self.client = Client()
    # Test that the retrieve list of payments functionality works correctly in the PaymentViewSet class.
    def test_retrieve_list_of_payments(self):
        # Create some dummy payments
        payment1 = Payment.objects.create(subscriber_id=1, amount=10.00, gateway_id=1, status="success")
        payment2 = Payment.objects.create(subscriber_id=2, amount=20.00, gateway_id=2, status="failed")
        payment3 = Payment.objects.create(subscriber_id=3, amount=30.00, gateway_id=1, status="pending")
    
        # Make a GET request to retrieve the list of payments
        response = self.client.get('/payments/')
    
        # Assert that the response status code is 200 (OK)
        self.assertEqual(response.status_code, 200)
    
        # Assert that the response data contains the correct number of payments
        self.assertEqual(len(response.data), 3)
    
        # Assert that the response data contains the correct payment details
        self.assertEqual(response.data[0]['subscriber'], payment1.subscriber_id)
        self.assertEqual(response.data[0]['amount'], str(payment1.amount))
        self.assertEqual(response.data[0]['gateway'], payment1.gateway_id)
        self.assertEqual(response.data[0]['status'], payment1.status)
    
        self.assertEqual(response.data[1]['subscriber'], payment2.subscriber_id)
        self.assertEqual(response.data[1]['amount'], str(payment2.amount))
        self.assertEqual(response.data[1]['gateway'], payment2.gateway_id)
        self.assertEqual(response.data[1]['status'], payment2.status)
    
        self.assertEqual(response.data[2]['subscriber'], payment3.subscriber_id)
        self.assertEqual(response.data[2]['amount'], str(payment3.amount))
        self.assertEqual(response.data[2]['gateway'], payment3.gateway_id)
        self.assertEqual(response.data[2]['status'], payment3.status)


    # Test that a new payment can be created successfully
    def test_create_new_payment(self):
        # Create a new payment
        payment_data = {
            'subscriber': 1,
            'amount': 10.00,
            'gateway': 1,
            'status': 'success'
        }
        response = self.client.post('/payments/', payment_data)
    
        # Assert that the payment was created successfully
        self.assertEqual(response.status_code, 201)
        self.assertEqual(Payment.objects.count(), 1)
        self.assertEqual(Payment.objects.first().subscriber_id, 1)
        self.assertEqual(Payment.objects.first().amount, 10.00)
        self.assertEqual(Payment.objects.first().gateway_id, 1)
        self.assertEqual(Payment.objects.first().status, 'success')


    # Test that the retrieve action of the PaymentViewSet returns the specific payment requested.
    def test_retrieve_specific_payment(self):
        # Create a payment object
        payment = Payment.objects.create(subscriber=self.user, amount=100.00, gateway=self.gateway, status="success")
    
        # Make a GET request to retrieve the payment
        response = self.client.get(f"/payments/{payment.id}/")
    
        # Assert that the response status code is 200 (OK)
        self.assertEqual(response.status_code, 200)
    
        # Assert that the retrieved payment matches the created payment
        self.assertEqual(response.data["id"], payment.id)
        self.assertEqual(response.data["subscriber"], payment.subscriber.id)
        self.assertEqual(response.data["amount"], str(payment.amount))
        self.assertEqual(response.data["gateway"], payment.gateway.id)
        self.assertEqual(response.data["status"], payment.status)


    # Test that the update method of PaymentViewSet updates an existing payment correctly.
    def test_update_existing_payment(self):
        # Create a payment object
        payment = Payment.objects.create(subscriber=self.user, amount=100, gateway=self.gateway, status="pending")
    
        # Update the payment
        updated_data = {
            "amount": 200,
            "status": "success"
        }
        response = self.client.put(f"/payments/{payment.id}/", updated_data)
    
        # Check that the payment was updated correctly
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["amount"], updated_data["amount"])
        self.assertEqual(response.data["status"], updated_data["status"])


    # Test that a payment is successfully deleted
    def test_delete_payment(self):
        # Create a payment object
        payment = Payment.objects.create(subscriber=self.user, amount=100, gateway=self.gateway, status="success")
    
        # Get the initial count of payments
        initial_count = Payment.objects.count()
    
        # Delete the payment
        response = self.client.delete(f"/payments/{payment.id}/")
    
        # Check that the payment is deleted
        self.assertEqual(response.status_code, 204)
        self.assertEqual(Payment.objects.count(), initial_count - 1)


    # Test that retrieving a payment that does not exist returns a 404 status code
    def test_retrieve_nonexistent_payment(self):
        # Create a dummy request object
        request = RequestFactory().get('/api/payments/1/')
    
        # Create a dummy viewset object
        viewset = PaymentViewSet()
        viewset.request = request
    
        # Call the retrieve method on the viewset
        response = viewset.retrieve(request, pk=1)
    
        # Assert that the response status code is 404
        self.assertEqual(response.status_code, 404)


    # Test that creating a payment with invalid data returns the appropriate error response
    def test_create_payment_with_invalid_data(self):
        # Create a request object with invalid data
        request = self.factory.post('/payments/', data={'subscriber': 1, 'amount': 'invalid', 'gateway': 1, 'status': 'success'})
    
        # Set the user as an authenticated admin user
        request.user = self.admin_user
    
        # Call the create method of the PaymentViewSet
        response = PaymentViewSet.as_view({'post': 'create'})(request)
    
        # Assert that the response status code is 400 (Bad Request)
        self.assertEqual(response.status_code, 400)
    
        # Assert that the response contains the appropriate error message
        self.assertEqual(response.data['amount'][0], 'Enter a valid number.')


    # Test that updating a payment with invalid data raises an error
    def test_update_payment_with_invalid_data(self):
        # Create a payment object
        payment = Payment.objects.create(subscriber=self.user, amount=100, gateway=self.gateway, status="success")
    
        # Attempt to update the payment with invalid data
        data = {
            "subscriber": self.user.id,
            "amount": "invalid",
            "gateway": self.gateway.id,
            "status": "success"
        }
        serializer = PaymentSerializer(payment, data=data)
        self.assertFalse(serializer.is_valid())
        self.assertEqual(serializer.errors, {"amount": ["Enter a valid number."]})


    # Test that deleting a payment that does not exist returns a 404 status code
    def test_delete_nonexistent_payment(self):
        # Create a new payment
        payment = Payment.objects.create(subscriber=self.user, amount=10.00, gateway=self.gateway, status="success")
    
        # Delete the payment
        response = self.client.delete(f"/payments/{payment.id + 1}/")
    
        # Assert that the response status code is 404
        self.assertEqual(response.status_code, 404)


    # Test that deleting a payment with 'success' status raises an exception
    def test_delete_payment_success_status(self):
        # Create a payment with 'success' status
        payment = Payment.objects.create(subscriber=user, amount=10.00, gateway=gateway, status='success')
    
        # Attempt to delete the payment
        with self.assertRaises(Exception):
            self.client.delete(f'/payments/{payment.id}/')


    # Test that only authenticated users can access the viewset
    def test_authenticated_users_access(self):
        # Create a mock request object
        request = RequestFactory().get('/payments/')
    
        # Create a mock user object
        user = User.objects.create_user(username='testuser', password='testpassword')
    
        # Set the user object as the authenticated user in the request
        force_authenticate(request, user=user)
    
        # Create an instance of the PaymentViewSet class
        payment_viewset = PaymentViewSet()
    
        # Call the list() method of the PaymentViewSet class with the mock request object
        response = payment_viewset.list(request)
    
        # Assert that the response status code is 200 (OK)
        self.assertEqual(response.status_code, 200)
    
        # Assert that the response data is not empty
        self.assertNotEqual(response.data, [])
    
        # Assert that the response data contains the expected fields
        self.assertIn('subscriber', response.data[0])
        self.assertIn('amount', response.data[0])
        self.assertIn('gateway', response.data[0])
        self.assertIn('status', response.data[0])
    
        # Assert that the response data contains the expected values
        self.assertEqual(response.data[0]['subscriber'], user.id)
        self.assertEqual(response.data[0]['amount'], '10.00')
        self.assertEqual(response.data[0]['gateway'], 'Test Gateway')
        self.assertEqual(response.data[0]['status'], 'success')


    # Test that only admin users can access the viewset
    def test_admin_access(self):
        # Create a regular user
        regular_user = User.objects.create(username='regular_user', password='password')
    
        # Create an admin user
        admin_user = User.objects.create(username='admin_user', password='password', is_staff=True)
    
        # Authenticate as the regular user
        self.client.force_authenticate(user=regular_user)
    
        # Make a GET request to the viewset
        response = self.client.get('/payment/')
    
        # Assert that the response status code is 403 (Forbidden)
        self.assertEqual(response.status_code, 403)
    
        # Authenticate as the admin user
        self.client.force_authenticate(user=admin_user)
    
        # Make a GET request to the viewset
        response = self.client.get('/payment/')
    
        # Assert that the response status code is 200 (OK)
        self.assertEqual(response.status_code, 200)


    # Test that the serializer returns all the expected fields
    def test_serializer_returns_expected_fields(self):
        # Create a payment object
        payment = Payment.objects.create(subscriber_id=1, amount=100.00, gateway_id=1, status="success")
    
        # Create a payment serializer instance
        serializer = PaymentSerializer(payment)
    
        # Verify that the serializer returns the expected fields
        expected_fields = ['id', 'subscriber', 'amount', 'gateway', 'status']
        self.assertEqual(set(serializer.data.keys()), set(expected_fields))


    # Test that the serializer validates the data correctly
    def test_serializer_validation(self):
        # Create a valid payment object
        payment_data = {
            'subscriber': 1,
            'amount': 10.0,
            'gateway': 1,
            'status': 'success'
        }
        serializer = PaymentSerializer(data=payment_data)
        self.assertTrue(serializer.is_valid())
    
        # Create an invalid payment object with missing required fields
        invalid_payment_data = {
            'subscriber': 1,
            'amount': 10.0
        }
        serializer = PaymentSerializer(data=invalid_payment_data)
        self.assertFalse(serializer.is_valid())
    
        # Create an invalid payment object with invalid field values
        invalid_payment_data = {
            'subscriber': 1,
            'amount': -10.0,
            'gateway': 1,
            'status': 'invalid'
        }
        serializer = PaymentSerializer(data=invalid_payment_data)
        self.assertFalse(serializer.is_valid())


    # Test that the viewset returns the expected HTTP status codes for different actions
    def test_http_status_codes(self):
        # Test list action
        response = self.client.get('/payments/')
        self.assertEqual(response.status_code, 200)

        # Test create action
        data = {
            'subscriber': 1,
            'amount': 10.0,
            'gateway': 1,
            'status': 'success'
        }
        response = self.client.post('/payments/', data)
        self.assertEqual(response.status_code, 201)

        # Test retrieve action
        response = self.client.get('/payments/1/')
        self.assertEqual(response.status_code, 200)

        # Test update action
        data = {
            'subscriber': 1,
            'amount': 20.0,
            'gateway': 1,
            'status': 'success'
        }
        response = self.client.put('/payments/1/', data)
        self.assertEqual(response.status_code, 200)

        # Test destroy action
        response = self.client.delete('/payments/1/')
        self.assertEqual(response.status_code, 204)

